# Redis



## ✅你们项目中为什么要使用缓存呢？你有用过Redis吗？

我用缓存主要是用于两个场景：

1、高并发

2、高性能

对于高并发，举个例子，如果有一个查询接口，并发大概1万 QPS，直接打在单机的MySQL数据库中，这个数据库绝对是承载不了的。这个时候我们就可以考虑上缓存了，redis缓存功能简单，单机支撑几万QPS还是轻轻松松的。

对于高性能，举个例子，同样是一个查询接口，但是这个接口的数据，几个小时都不会变化，这个时候我们就可以考虑先读缓存里面的数据，就没有必要每次都去数据库里面查询了。

## ✅为什么Redis是单线程的，效率还这么高？你能简单说一下Redis的线程模型吗？

1、基于内存

2、单线程模型避免了上线文切换

我们所说的Redis单线程，指的是"其网络IO和键值对读写是由一个线程完成的"，也就是说，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。

`Redis没有用多线程处理IO操作，主要是因为，Redis的操作基本都是基于内存的，CPU资源根本就不是Redis的性能瓶颈。`

3、I/O多路复用技术

Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互，当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。



`生活中的例子`

`想象一下在一个繁忙的酒吧中，有多个顾客同时点了饮料。酒吧服务员需要处理来自不同顾客的点单请求，并尽可能快地为每个顾客提供所需的饮料。这里的服务员可以类比为操作系统中的I/O多路复用机制。` 

`在这个例子中，服务员代表操作系统，顾客代表应用程序或网络连接。服务员需要处理多个顾客的点单请求，而不是按顺序逐个处理。这就类似于I/O多路复用技术中的事件驱动机制，其中操作系统可以同时监听多个I/O事件，而不是按顺序一个接一个地处理。`

 `服务员在这个例子中的角色是非常关键的。他们可以通过以下方式实现多路复用：`

1. `使用单一的I/O通道：服务员可以将所有顾客的点单请求都集中在一个单一的I/O通道中，这样他们只需要监视一个通道，而不是每个顾客一个通道。类似地，在操作系统中，可以使用一个I/O多路复用机制（如select、poll或epoll）来监听多个网络连接或文件描述符的事件。`
2. `非阻塞处理：服务员可以采用非阻塞的方式处理点单请求。当一个顾客点单后，服务员不需要等待该顾客的饮料准备完成，而是继续接受其他顾客的点单。在操作系统中，非阻塞I/O允许应用程序在等待一个I/O操作完成时继续处理其他事务，而不会被阻塞。`
3. `异步通知：当顾客的饮料准备完成后，服务员可以通过呼叫或者其他方式通知相应的顾客。这类似于操作系统中的异步通知机制，其中操作系统可以在I/O事件准备就绪后通知应用程序进行处理。`



## ✅说一下Redis的过期策略和缓存淘汰机制，你能手写一个LRU算法吗？

Redis的过期策略和缓存淘汰机制是管理缓存中键值对的关键机制，用于控制缓存中数据的生命周期和内存的使用。

过期策略（Expiration Policy）：

 Redis中的过期策略用于定义键值对的过期时间，以决定何时自动从缓存中删除。以下是Redis支持的过期策略：

1、定时删除（定期删除）：在设置键的过期时间时，同时创建一个定时器，在指定的时间到达时删除键值对。这种策略的优点是在内存使用上相对均匀，但删除过期键的时间取决于定时器的执行频率。
2、惰性删除：在访问某个键时，先检查键是否过期，如果过期则删除。这种策略的优点是可以避免定时删除策略中的批量删除操作，但缺点是在过期键没有被访问时会一直保留在内存中。
Redis默认使用定时删除策略，在每个Redis实例中都有一个专门负责过期键检查和删除的定时任务。

缓存淘汰机制：

 当Redis的内存空间被耗尽时，为了腾出空间来存储新的键值对，需要根据缓存淘汰机制删除一些旧的键值对。以下是Redis支持的缓存淘汰机制：

1、LRU（Least Recently Used）：最近最少使用策略，删除最近最少使用的键值对。Redis会记录键的访问时间，并根据最近访问时间进行淘汰。
2、LFU（Least Frequently Used）：最不经常使用策略，删除访问频率最低的键值对。Redis会记录键的访问次数，并根据访问次数进行淘汰。
3、Random（随机）：随机选择键值对进行淘汰。
4、TTL（Time To Live）：根据键的过期时间进行淘汰，删除最先过期的键值对。
Redis允许通过配置文件或命令来选择使用不同的缓存淘汰机制。默认情况下，Redis使用的是LRU策略。

需要注意的是，Redis的过期策略和缓存淘汰机制是两个独立的概念。过期策略用于设置键值对的过期时间和自动删除，而缓存淘汰机制用于在内存不足时选择要删除的键值对。



## ✅什么是缓存雪崩、缓存穿透、缓存击穿？分别什么解决方案？

缓存雪崩，主要是由于缓存崩溃了，大量的请求打到了数据库上，而数据库扛不住这么高的并发，挂了又挂，最后造成整个服务不可用。我觉得比较好的应对方案应该分为3个方面，1、事前，做好redis集群的高可用和高并发，比如主从+哨兵，redis cluster等。2、事中，除了redis缓存，我们还可以考虑程序自身的内存缓存，对于某些接口，我们还可以考虑限流降级等措施。3、事后，做好了redis的持久化，一但重启，可以快速恢复数据。



缓存穿透，这个指的是请求的数据，在redis和数据库都没有，所以每来一次，都会进行一次DB操作，量大了，一样会把数据库打崩。我们常见的应对方案是，针对这种在数据库中没查到的数据，我们一样给个值放在redis中。



缓存击穿，指的是大数量key在同一时间过期了，大量的数据就直接击穿了缓存，直接打到了数据库上。我们常见的处理方式有设置热点key永不过期。



## ✅redis的持久化方式有哪些？都有什么优缺点？你了解他们的原理吗？

我使用的redis版本，持久化方式有3种，RDB、AOF，还有就是混合持久化。 

RDB：快照

AOF：命令追加

混合持久化：RDB+AOF



## ✅你们项目中是如何保证缓存和数据库数据的一致性？

为了保证缓存和数据库的一致性，我们一般会采用缓存和数据库双写的方式。

说道双写那么就有2种情况：

1、先操作数据库，后操作缓存

2、先操作缓存，后操作数据库

在并发量大的情况下，可以考虑延迟双删的方案，即先修改数据库，再删除缓存，等待一定时间后，再删除一次缓存。

在并发量小的情况下，可以考虑先删除缓存，再修改数据库。



## ✅Redis sentinel集群和Cluster集群有什么区别?

首先，集群，我们首先想到的是主从集群，但是Redis的主从，只能做数据备份，当主发生宕机的情况下，从是不能够自动升级为主的。

所以我们需要一些其他的自动灾备集群方案。最常见的是2种，一种是sentinel哨兵集群，一种的cluster集群。

至于它们的区别主要有以下几个点:

1.Redis 哨兵集群是单独启动哨兵服务对主从节点进行监控，所以原则上还是主从，只不过哨兵实现了主从自动故障转移，它可以实现读写分离，分担Redis读操作的压力。而Redis Cluster 集群的Slave节点只是实现冷备机制，它只有在Master宕机之后才会工作.

2.从集群架构上来说，Redis 哨兵集群是一主多从，而Redis Cluster是多主多从

3.哨兵集群是一主多从，所有的数据都会存储在我的主，而cluster集群数据会通过虚拟槽的分片机制分配到不同的主服务器，所以扛压这块，哨兵集群受限于单个服务器的资源配置，而cluster是多主联合扛压。

4.RedisCluster集群，采用虚拟槽的分片机制，能够灵活的在线进行扩容、缩容，以及灵活的进行数据隔离



## ✅为什么高并发下，设置库存，每次操作减一，使用watch+事务会出现库存遗留问题？

因为redis的事务并不保证原子性，和数据库不一样，数据库是保证原子性的，也就是说redis同一个事务里的操作，可能只成功一半。而lua脚本是保证原子性的，这种场景，我觉得最好还是考虑用lua脚本做。





