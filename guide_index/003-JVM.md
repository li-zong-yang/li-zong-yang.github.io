# JVM

> ## 程序的运行步骤

1. 首先把“.java”代码文件编译成“.class”字节码文件；
2. 然后类加载器把“.class”字节码文件中的类给加载到 JVM 中 ；
3. 接着是 JVM 执行类中的代码。

![线程池流程](media/程序的运行步骤.png)



> ## JVM 类加载机制

关于类的加载机制，我这里总结成了3个步骤，4个阶段。

3个步骤就是程序的运行步骤

1. 首先把“.java”代码文件编译成“.class”字节码文件；
2. 然后类加载器把“.class”字节码文件中的类给加载到 JVM 中；
3. 接着是 JVM 执行类中的代码。

4个阶段为：

1. 验证这个环节主要是确定 JVM 加载的.class 文件是符合规范的，就好比男人去男厕所，女人去女厕所，符合 JVM 规范的才能进入到 JVM。
2. 准备这个环节主要是给类以及类变量分配内存空间。
3. 解析这个环节主要是把符号引用替换为直接引用。
4. 初始化这个环节主要主要做的是赋值。 

针对初始化有一个重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类。

![线程池流程](media/JVM类加载机制.png)

> ## 双亲委派机制

说到双亲委派，有的同学第一时间想到的就是，JAVA之父，马老师和余老师，实际上不是这样的。双亲并不是指两个爸爸，而是更像爸爸与爷爷的关系。

双亲委派主要体现在ClassLoader.loadClass方法中，说人话就是儿子想要一个东西，他会先给爸爸讲，但是爸爸不会马上给他找，爸爸会告诉爷爷，让爷爷先找有没有这个东西，如果爷爷没有找到，就会告诉爸爸，让爸爸去找。

总结成一句话就是：向上委派，向下查找。

![线程池流程](media/双亲委派.png)



> ## JVM 内存区域划分

通过JVM 的类加载机制，我们知道了类会被 JVM 加载到内存中以便使用，但是这些类被加载到内存以后，放在哪里去了呢？这个就要涉及到 JVM 的内存区域划分了。

首先我们加载了一个类，所以我们需要一块空间来存放类信息，这块空间在 JVM 中叫做元数据区或者方法区。

接着需要将.class 文件翻译成字节码，所以 JVM 使用字节码引擎，执行字节码指令，使用程序计数器，记录指令位置。

然后每一个程序计数器会对应一个线程，如果线程执行了一个方法，就会对这个方法创建一个栈帧。栈帧里包含了方法的局部变量。以上所有数据统称为 JAVA 虚拟机栈。

JAVA 虚拟机栈中的局部变量，会指向另一片区域中的对象地址，这一片存放对象的区域叫做 JAVA 虚拟机堆。

![线程池流程](media/JVM内存区域划分.png)