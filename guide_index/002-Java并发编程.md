

![线程池流程](https://img.52javaee.com/blog20241008223934.jpg)

# JAVA并发编程

> 第七人格



## ✅谈谈你对线程池的理解

线程池可以理解为一些线程的集合，创建线程池有几个参数：

1、核心线程数

2、最大线程数

3、非核心线程的存活时间

4、存活时间单位

5、用来保存任务的队列

6、创建队列的工厂

7、线程池的拒绝策略



```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```



线程池执行流程稍稍有点复杂，我们这里拿工作举例，假如你们部门一共有10个编制（最大线程数），正式编制2个（核心线程数），外包编制8个，当任务量不大的时候，老板只需要让2个正式员工做就可以了，但是有一天任务太多了，这个时候就需要招点外包人员帮助处理任务，但是不能超过总的编制。如果10个人也做不完，那么老板就会出面，决定接下来怎么做（4种拒绝策略）。如果10个人可以顺利处理掉任务，并且都没任务的积压了，大家都摸鱼一段时间了（keepAliveTime），老板就会开人，只留下2个人员（核心线程数）就可以了，但是不保证这两个人员还是以前那两个。

![线程池流程](https://img.52javaee.com/blog20241008223938.jpg)

## ✅什么是daemon线程？

daemon线程，中文翻译为守护线程。

简单来说，一般工作线程是非daemon线程，后台线程是daemon线程，也就是说我们默认创建的都是工作线程，如果想要将一个线程设置为守护线程，需要调用 该线程的setDaemon(true) 方法。daemon线程和工作线程最大的区别是，如果jvm里的工作线程都停止了，那么daemon线程会跟着jvm进程一起退出。

举个例子，微服务注册中心中负责监控微服务存活状态的线程，一般设置的就是守护线程，这样如果工作线程都死了，那么jvm也就退出了，daemon线程也随着jvm的退出销毁了。



## ✅说一说CPU缓存模型

摩尔定律是英特尔创始人之一戈登·摩尔的经验之谈，其核心内容为：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍。但是现代的计算机技术，在内存的读写速度方面却没什么突破。为了避免cpu频繁读写主内存，大佬们想了一个方法，给cpu加了几层缓存，也就是说cpu可以直接操作自己的缓存，而不需要和主内存频繁的通信，这就是CPU的缓存模型。

![线程池流程](https://img.52javaee.com/blog20241008223944.jpg)

但是在多线程访问的情况下，该缓存模型是有问题的。比如说各个cpu的本地缓存，跟主内存没有同步，那么同一个数据在各个地方都有可能是不一致的，这就会造成并发问题。为了解决这个问题，大佬们又坐在一起，敲定了MESI协议，即缓存一致性协议。该协议主要借助cpu的嗅探机制，大致原理为：如果本地缓存修改了，那么会立马刷回主内存，其他cpu缓存也会马上清空，并重新从主内存加载数据。

![线程池流程](https://img.52javaee.com/blog20241008223949.png)





## ✅JAVA内存模型(JMM)

JMM是基于CPU缓存模型的

![线程池流程](https://img.52javaee.com/blog20241008223956.png)





## ✅并发三大特性

原子性、可见性、有序性

https://mp.weixin.qq.com/s/WYJQ1Euo5-FaV561WYX0Ag



## ✅volatile是如何保证可见性的?

底层原理主要是靠lock前缀指令以及MESI协议。

https://mp.weixin.qq.com/s/al1TvYI29y9IevG3LbCCjg





## ✅volatile为何不保证原子性?

`volatile`关键字在Java中，可以保证可见性和有序性的原因我们大概了解了，那他是为何不保证原子性的呢？

**底层实现机制**：

- • 在底层，`volatile`变量通过Lock前缀指令和缓存一致性协议来实现其特性。
- • Lock前缀指令确保了对`volatile`变量的读写操作是原子性的，但这仅限于单个读写操作。
- • 缓存一致性协议确保了对`volatile`变量的修改会立即传播到其他线程，但这同样不涉及复合操作的原子性。

**复合操作的非原子性**：

- • 复合操作（如`i++`或`a += b`）涉及多个步骤，包括读取、修改和写入。
- • 即使单个步骤（如读取或写入）是原子性的，整个复合操作也不是原子性的，因为中间状态可能会被其他线程观察到或修改。

**线程切换和中断**：

- • 在多线程环境中，线程可能会在执行复合操作的过程中被切换或中断。
- • 这可能导致复合操作被部分执行，从而导致数据不一致或竞争条件。





## ✅volatile如何保证有序性的？

happens-before原则

内存屏障



## ✅volatile使用的场景

1、单例模式 - 双重检索



## ⚠️多线程安全问题产生的根本原因

多线程并发写的问题

java内存模型



## ✅synchronized的底层原理

同一时间只有一个线程能够读写主内存。 synchronized可以对两种对象加锁，对象实例，Class对象。 你如果用到了synchronized关键字，在底层编译后的jvm指令中，会有monitorenter和monitorexit两个指令 每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor，如果要对这个对象加锁，那么必须获取这个对象关联的monitor的lock锁 他里面的原理和思路大概是这样的，monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1 这个monitor的锁是支持重入加锁的 

```java
synchronized(myObject) { 

// 一大堆的代码 synchronized(myObject) { 

// 一大堆的代码 } 

}

```



## ✅synchronized锁升级

无锁->偏向锁->轻量级锁->重量级锁 

无锁：当一个线程第一次访问一个对象的同步块时，JVM会在对象头中设置该线程的Thread ID，并将对象头的状态位设置为“偏向锁”。这个过程称为“偏向”，表示对象当前偏向于第一个访问它的线程。 

偏向锁：偏向锁是指在只有一个线程访问对象的情况下，该线程不需要使用同步操作就可以访问对象。这种情况下，JVM会在对象头中记录该线程的ID 作为偏向锁的持有者，并将对象头中的 Mark Word 中的一部分作为偏向锁标识在这种情况下，如果其他线程访问该对象，会先检查该对象的偏向锁标识，如果和自己的线程 ID 相同，则直接获取锁。如果不同，则该对象的锁状态就会升级到轻量级锁状态。 

轻量级锁：在轻量级锁状态中，JVM 为对象头中的 Mark Word 预留了一部分空间，用于存储指向线程栈中锁记录的指针.当一个线程访问该对象时，JVM 会将对象头中的 Mark Word 复制一份到线程栈中，并在对象头中存储线程栈中C的指针。此时，如果另一个线程想要访问该对象，会发现该对象已经外干轻量级锁状态，并尝试使用 CAS 操作将线程栈中的指针替换成自己的指针。如果替换成功，则该线程获取锁成功:如果失败，则表示已经有其他线程获取了锁，则该锁状态就会升级到重量级锁状态。 

重量级锁：当锁状态升级到重量级锁状态时，JM 会将该对象的锁变成一个重量级锁，并在对象头中记录指向等待队列的指创此时，如果一个线程想要获取该对象的锁，则需要先进入等待队列，等待该锁被释放。当锁被释放时，JVM 会从等待队列中选择一个线程唤醒，并将该线程的状态设置为“就绪”状态，然后等待该线程重新获取该对象的锁。







## ⚠️synchronized的3次自旋







## ⚠️synchronized锁优化

锁自旋一般是用while，但是这个用得是c代码  

锁消除jvm增加逃逸分析，可以不加锁的地方，加了锁，jvm可以把他干掉  

锁粗化







## ⚠️wait和notify/notifyAll









## ⚠️Atomic原子类底层核心原理

CAS无锁话，乐观锁，Unsafe类 

volatile int value = 0 

valueOffset（value字段在AtomicInteger类中的位置）





## ✅CAS无锁化原理和思路

CAS（Compare And Swap）是一种无锁化的操作技术，常用于并发编程中。其基本思路和原理如下：

无锁化设计: CAS操作不依赖于传统的互斥锁，它允许多个线程同时尝试更新共享资源，而不需要等待其他线程释放锁。
乐观锁机制: CAS是基于乐观锁的概念实现的。乐观锁假设在大多数情况下，多个线程不会同时修改同一个数据，因此不需要立即上锁，而是在数据实际被访问时再进行检查。
原子性操作: CAS通过硬件支持的原子指令来实现比较和替换操作，确保了整个操作过程中不会被打断，从而避免了多线程之间的竞争条件。
内存可见性: 当一个线程对共享变量执行CAS操作并成功时，这个操作对于其他所有线程都是可见的，这保证了内存的可见性和一致性。
失败重试机制: 如果多个线程同时尝试更新同一个值，只有其中一个线程能够成功执行CAS操作，其他线程会因为CAS操作失败而进行重试。这种机制虽然可能导致忙等待，但在某些场景下可以提高性能。
ABA问题: CAS操作存在一个被称为ABA问题的潜在风险，即一个值在被读取之后可能先被改变为另一个值，然后又变回原来的值，导致CAS操作误判为没有发生变化。解决这个问题通常需要额外的逻辑或者使用带有版本号的原子变量。
适用场景: CAS适用于那些写操作远少于读操作的场景，因为它可以减少锁带来的开销。在高竞争的环境下，CAS可能会导致性能下降，因为失败的CAS操作需要进行不断的重试。
实现方式: 在Java中，java.util.concurrent.atomic包提供了一系列的原子类，如AtomicInteger、AtomicLong等，这些类内部使用了CAS操作来保证线程安全。
与其他同步机制对比: 与传统的synchronized关键字或Lock接口提供的互斥锁相比，CAS操作提供了一种更轻量级的线程同步手段，它可以在特定条件下提供更好的性能。







## ✅底层CPU指令是如何实现CAS语义的

底层CPU指令实现CAS（Compare-And-Swap）语义主要依赖于处理器提供的特殊原子操作指令。这些指令可以在多线程环境下，无需锁的情况下保证对内存的原子性访问和更新。

具体来说，CAS操作通常涉及以下几个关键步骤：

读取内存位置的值：首先，CPU会读取指定内存地址上的值，这个值用于后续的比较。
比较预期值与内存值：接着，CPU会比较该内存地址当前的值是否与预期的值相等。这个预期值是CAS指令执行前，程序预先提供的。
写入新值：如果内存地址的值与预期值相同，说明没有其他线程在此期间修改过该值，CPU就会将新值写入该内存地址。
返回旧值：无论比较结果如何，CPU都会返回内存地址在操作开始时的值。
这些步骤是原子性的，意味着在整个过程中不会被其他线程的操作打断。这种原子性保证了即使在多线程并发访问同一个内存地址时，每个线程也能安全地执行CAS操作。

在不同的编程语言和平台上，CAS操作的具体实现可能会有所不同，但其底层原理都是基于CPU提供的原子操作指令。这些指令通常包括CMPXCHG（比较并交换）在x86架构上，或是LL/SC（加载链接/存储条件）在SPARC架构上。



## ✅Atomic原子类CAS语义存在的3大问题

1、ABA问题 

2、无限循环问题LongAdder，通过分段CAS机制优化多线程自旋问题 分段迁移，某一个线程如果对一个Cell更新的时候，发现说出现了很难更新他的值，出现了多次自旋的一个问题，如果他CAS失败了，自动迁移段，他会去尝试更新别的Cell的值，这样的话就可以让一个线程不会盲目的等待一个cell的值  

3、多变量原子性问题







## ⚠️ReentractLoc和ReadWriteReentractLock

底层都是基于AQS实现的



## ✅谈一谈AQS抽象队列同步器

其实就是2个东西，一个状态，两个队列。它使用一个int类型的state来表示同步状态，并通过内置的FIFO队列来完成资源获取线程的排队工作。

https://mp.weixin.qq.com/s/JxSgsR4RcLeVvmlpofpmBQ



## ✅为什么在Java中一个方法栈里面的操作是线程安全的

在Java中，一个方法栈（通常指的是线程的调用栈或Java虚拟机栈）里面的操作被认为是线程安全的，这主要是由于Java内存模型以及线程栈的设计特性所决定的。以下是详细解释：

1. 线程栈的私有性

Java内存模型将Java虚拟机内部划分为线程栈（Thread Stack）和堆（Heap）等区域。每个线程在创建时都会分配一个私有的线程栈，用于存储该线程执行过程中的方法调用、局部变量等信息。由于线程栈是私有的，即每个线程都有自己的栈空间，因此一个线程中的操作不会直接影响到其他线程的栈空间，从而保证了线程栈内部操作的线程安全性。

2. 局部变量和参数的线程安全性

方法栈中存储的主要信息是局部变量表和操作数栈。局部变量表用于存储方法的参数以及方法内部定义的局部变量，这些变量在方法调用时分配，在方法结束时销毁。由于局部变量和参数都存储在各自线程的栈空间中，因此它们对其他线程是不可见的，这自然保证了这些操作的线程安全性。

3. 指令执行的有序性和原子性

虽然CPU的指令执行可能会因为优化而出现重排序，但在Java内存模型中，通过内存屏障等技术手段，可以确保对于单个线程而言，其指令的执行顺序是符合程序员预期的，即保持有序性。同时，对于局部变量和参数的赋值等操作，由于它们仅涉及单个线程的栈空间，因此这些操作在单个线程内部通常是原子的，不会被其他线程干扰。

4. 避免共享资源的竞争

线程安全问题通常发生在多个线程尝试同时访问和修改共享资源时。由于线程栈是私有的，不存在线程间对栈空间资源的竞争，因此线程栈内部的操作不会引发线程安全问题。然而，如果方法内部访问了堆上的共享对象，那么就需要通过同步机制（如synchronized关键字、Lock接口等）来确保线程安全。

综上所述，Java中一个方法栈里面的操作之所以是线程安全的，主要是因为线程栈的私有性、局部变量和参数的线程隔离性、指令执行的有序性和原子性，以及避免了共享资源的竞争。这些特性共同保证了单个线程在执行方法时，其内部操作不会受到其他线程的干扰。





## ✅你使用过ThreadLocal吗

在开发消息中心的时候，我使用它作为过日志上下文的存储。

ThreadLocal是Java中用于解决多线程并发问题的一个类，它提供了一种线程局部变量，每个线程都可以通过它访问到自己的变量副本，而不会和其他线程的变量副本冲突

ThreadLocal内部通过ThreadLocalMap来存储每个线程的变量副本。每个线程Thread内部都维护一个ThreadLocalMap类型的threadLocals变量，用于存储该线程的所有ThreadLocal变量。

ThreadLocalMap中的元素是以Entry的形式存在的，每个Entry都包含了一个ThreadLocal的弱引用和一个Object类型的值，这个值就是线程局部变量的副本。





## ✅为什么要使用ThreadLocal

使用ThreadLocal作为日志上下文的存储，在多线程环境中具有显著的好处，主要体现在以下几个方面：

1. 线程隔离与独立性

* **数据隔离**：ThreadLocal为每个线程提供了独立的变量副本，这意味着每个线程都可以独立地存储和访问自己的日志上下文信息，而不会与其他线程的日志上下文信息冲突。这保证了日志信息的线程隔离性和独立性。

2. 简化编程模型

* **避免显式传递**：在不使用ThreadLocal的情况下，为了在多线程环境中传递日志上下文，可能需要在多个方法调用之间显式地传递日志上下文对象。这不仅增加了编程的复杂度，还可能导致代码难以维护。使用ThreadLocal可以避免这种显式的传递，使代码更加简洁和清晰。

3. 提高性能

* **减少锁的使用**：由于ThreadLocal为每个线程提供了独立的变量副本，因此在获取和设置日志上下文时，不需要使用同步机制（如锁）来保护共享数据。这减少了锁的使用，降低了线程间的竞争，从而提高了程序的并发性能。

4. 便于日志追踪与问题排查

* **上下文信息关联**：在多线程环境中，日志记录是排查问题的重要手段。通过将日志上下文信息（如用户ID、会话ID等）存储在ThreadLocal中，可以在日志中自动关联这些上下文信息，从而方便追踪和排查问题。当出现问题时，可以通过日志快速定位到具体的线程和上下文环境。

5. 灵活性

* **易于扩展**：随着应用程序的发展，可能需要记录更多的日志上下文信息。使用ThreadLocal可以方便地扩展日志上下文信息，只需在ThreadLocal中存储新的上下文信息即可，无需修改现有的日志记录逻辑。





## ✅try-catch中能捕获到子线程的异常吗？

不能。线程隔离原理。