# JAVA并发编程

> ## 谈谈你对线程池的理解

线程池可以理解为一些线程的集合，创建线程池有几个参数：

1、核心线程数

2、最大线程数

3、非核心线程的存活时间

4、存活时间单位

5、用来保存任务的队列

6、创建队列的工厂

7、线程池的拒绝策略



```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```



线程池执行流程稍稍有点复杂，我们这里拿工作举例，假如你们部门一共有10个编制（最大线程数），正式编制2个（核心线程数），外包编制8个，当任务量不大的时候，老板只需要让2个正式员工做就可以了，但是有一天任务太多了，这个时候就需要招点外包人员帮助处理任务，但是不能超过总的编制。如果10个人也做不完，那么老板就会出面，决定接下来怎么做（4种拒绝策略）。如果10个人可以顺利处理掉任务，并且都没任务的积压了，大家都摸鱼一段时间了（keepAliveTime），老板就会开人，只留下2个人员（核心线程数）就可以了，但是不保证这两个人员还是以前那两个。

![线程池流程](media/线程池流程.jpg)

> ## 什么是daemon线程？

daemon线程，中文翻译为守护线程。

简单来说，一般工作线程是非daemon线程，后台线程是daemon线程，也就是说我们默认创建的都是工作线程，如果想要将一个线程设置为守护线程，需要调用 该线程的setDaemon(true) 方法。daemon线程和工作线程最大的区别是，如果jvm里的工作线程都停止了，那么daemon线程会跟着jvm进程一起退出。

举个例子，微服务注册中心中负责监控微服务存活状态的线程，一般设置的就是守护线程，这样如果工作线程都死了，那么jvm也就退出了，daemon线程也随着jvm的退出销毁了。



> ## 说一说CPU缓存模型

摩尔定律是英特尔创始人之一戈登·摩尔的经验之谈，其核心内容为：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍。但是现代的计算机技术，在内存的读写速度方面却没什么突破。为了避免cpu频繁读写主内存，大佬们想了一个方法，给cpu加了几层缓存，也就是说cpu可以直接操作自己的缓存，而不需要和主内存频繁的通信，这就是CPU的缓存模型。

![线程池流程](media/cpu缓存模型.jpg)

但是在多线程访问的情况下，该缓存模型是有问题的。比如说各个cpu的本地缓存，跟主内存没有同步，那么同一个数据在各个地方都有可能是不一致的，这就会造成并发问题。为了解决这个问题，大佬们又坐在一起，敲定了MESI协议，即缓存一致性协议。该协议主要借助cpu的嗅探机制，大致原理为：如果本地缓存修改了，那么会立马刷回主内存，其他cpu缓存也会马上清空，并重新从主内存加载数据。

![线程池流程](media/CPU缓存下的并发问题.png)





> ## JAVA内存模型(JMM)







> ## 并发三大特性





> ## volatile是如何保证可见性的?





> ## volatile为何不保证原子性?





> ## volatile如何保证有序性的？





> ## volatile使用的场景





> ## 多线程安全问题产生的根本原因





> ## synchronized的底层原理







> ## synchronized锁升级





> ## synchronized的3次自旋







> ## synchronized锁优化





> ## wait和notify/notifyAll





> ## Atomic原子类底层核心原理





> ## CAS无锁化原理和思路





> ## 底层CPU指令是如何实现CAS语义的





> ## Atomic原子类CAS语义存在的3大问题





> ## ReentractLoc和ReadWriteReentractLock





> ## 谈一谈AQS抽象队列同步器