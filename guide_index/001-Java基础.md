![线程池流程](media/公众号.jpg)

# Java基础

> 第七人格

## String为什么是不可变的？

String 被声明为 `final`，因此它不可被继承。

在 Java 8 中，String 内部使用 char 数组存储数据。value 数组也被声明为 final，意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

**如果你非要修改他，可以通过反射的方式修改其value，达到修改String的目的。**

不可变的好处

1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 
2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 
3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。
4.  线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。



## 面向对象和面向过程的区别

**面向过程**：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发

**面向对象**：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有**封装、继承、多态**的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。



## 重载和重写的区别

**重写(Override)**

从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。

**重写 总结：** 

1.发生在父类与子类之间 

2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 

3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) 

4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

**重载（Overload）**

在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

**重载 总结：** 

1.重载Overload是一个类中多态性的一种表现 

2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 

3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准



## equals与==的区别

**==** **：**

== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。

1、比较的是操作符两端的操作数是否是同一个对象。 

2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 

3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地

址为10的堆。

**equals**：

equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。

总结：

所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针。

在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals。



## 枚举对象你是用equals还是==比较的？

在Java中，枚举（Enums）是一种特殊的类，用来表示一组常量。每个枚举实例都是public static final的，因此它们在创建时就被显式地初始化了。枚举的equals()方法默认行为是比较两个枚举实例的引用是否相同，这与==操作符的行为是一致的，所以使用==和equals()来比较枚举实例通常是等效的。





##  为什么不能用BigDecimal的equals方法做等值比较?

在使用`BigDecimal`类进行等值比较时，通常不推荐直接使用`equals`方法，这主要是因为`BigDecimal`的`equals`方法会比较两个`BigDecimal`对象的值以及它们的标度（scale）。标度是指小数点后的位数，即精度。这意味着，即使两个`BigDecimal`对象在数值上相等，但它们的标度不同，`equals`方法也会返回`false`。

例如：

```java
BigDecimal bd1 = new BigDecimal("1.00");
BigDecimal bd2 = new BigDecimal("1");

System.out.println(bd1.equals(bd2)); // 输出 false
```

在这个例子中，`bd1`和`bd2`在数值上是相等的，但它们的标度不同（`bd1`的标度是2，而`bd2`的标度是0）。因此，`equals`方法返回`false`。

为了进行数值上的等值比较，而不考虑标度，你应该使用`compareTo`方法，或者更简洁地，使用`BigDecimal`提供的`stripTrailingZeros`方法（如果标度差异是问题所在）来规范化数值，然后再使用`equals`方法，或者直接使用`compareTo`方法与0进行比较：

```java
BigDecimal bd1 = new BigDecimal("1.00");
BigDecimal bd2 = new BigDecimal("1");

// 使用 compareTo 进行等值比较
System.out.println(bd1.compareTo(bd2) == 0); // 输出 true

// 或者先规范化数值
System.out.println(bd1.stripTrailingZeros().equals(bd2.stripTrailingZeros())); // 输出 true
```

`compareTo`方法会返回-1、0或1，分别表示第一个操作数小于、等于或大于第二个操作数。因此，当你想要检查两个`BigDecimal`对象是否数值相等时，可以使用`compareTo`方法与0进行比较。

总的来说，由于`BigDecimal`的`equals`方法同时考虑了数值和标度，所以在进行数值等值比较时，使用`compareTo`方法是一个更安全、更可靠的选择。





## 有没有可能两个不相等的对象有相同的hashcode

有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以下几种方式来处理:

1、拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.

2、开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入List<Integer> iniData = new ArrayList<>()

3、再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突



## Java中 String有长度限制吗？

先回答结果：有。

String内部是使用一个char数组来维护字符序列的，而数组的长度在Java中是用整型（int）来表示的。整型（Java中int为32位）的取值范围是-2^31到2^31-1，因此，从理论上讲，String的最大长度可以是Integer.MAX_VALUE，即2^31-1个字符。

并且我以前写单元测试的时候，遇到过这么个情况，当时是要使用一个base64文件，我为了偷懒，直接new的一个String，将base64的字符串直接放在了常量池中，结果运行就报错了

> java: 常量字符串过长

但是以读取文件的方式，放在String中就不会发生这个情况了。这也说明运行期的限制和常量池的限制是不一样的。具体来说，由于常量池中的字符串以CONSTANT_Utf8_info结构表示，其长度字段是一个无符号的16位整数（u2），因此理论上字符串常量的最大长度是2^16-1（即65535），要小的多。



## JAVA中的值传递机制

1. **基本数据类型**：当基本数据类型的变量作为参数传递给方法时，Java会创建一个参数的副本，并将实际参数的值复制到这个副本中。因此，在方法内部对参数的任何修改都不会影响到原始变量。
2. **引用数据类型**：对于引用类型的变量，Java传递的是对象引用的副本，而不是对象本身。这意味着方法内部可以通过这个副本（即引用）访问和修改对象的状态（如对象的属性），但这些修改是通过引用指向的对象进行的，而不是修改了引用本身。因此，如果方法内部改变了对象的属性，这些改变会反映到原始对象上。但是，如果方法内部让引用指向了一个新的对象，这个改变不会影响到原始引用。

示例1：基本数据类型的值传递

```java
public class PassByValueExample {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 20;
        swap(num1, num2); // 尝试交换num1和num2的值
        System.out.println("num1 = " + num1); // 输出: num1 = 10
        System.out.println("num2 = " + num2); // 输出: num2 = 20
    }

    public static void swap(int a, int b) {
        int temp = a;
        a = b;
        b = temp;
        System.out.println("a = " + a); // 方法内部交换了a和b的值
        System.out.println("b = " + b); // 但这不会影响到main方法中的num1和num2
    }
}
```

在这个示例中，`swap`方法试图交换两个整数参数的值。然而，由于Java采用值传递机制，`swap`方法接收的是`num1`和`num2`的副本，而不是它们本身。因此，在`swap`方法内部对参数的任何修改都不会影响到原始变量`num1`和`num2`。

示例2：引用数据类型的值传递（传递引用值）

```java
public class ArrayExample {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        modifyArray(arr); // 尝试修改数组的第一个元素
        System.out.println(arr[0]); // 输出: 0，因为数组的第一个元素被修改了
    }

    public static void modifyArray(int[] array) {
        array[0] = 0; // 修改数组的第一个元素
    }
}
```

在这个示例中，`modifyArray`方法接收一个整型数组的引用作为参数。虽然传递的是引用值（即数组在内存中的地址），但Java仍然遵循值传递的原则。这意味着`modifyArray`方法接收的是数组引用的副本，而不是数组本身。然而，由于引用副本和原始引用都指向同一个数组对象，因此通过引用副本对数组对象所做的修改会反映到原始数组上。

示例3：对象作为参数的值传递

```java
public class Student {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

public class ObjectExample {
    public static void main(String[] args) {
        Student student = new Student("张三");
        changeName(student); // 尝试修改学生的名字
        System.out.println(student.getName()); // 输出: 李四，因为学生的名字被修改了
    }

    public static void changeName(Student s) {
        s.setName("李四"); // 修改对象的属性
    }
}
```

在这个示例中，`changeName`方法接收一个`Student`对象的引用作为参数。同样地，由于Java采用值传递机制，`changeName`方法接收的是对象引用的副本。但是，由于引用副本和原始引用都指向同一个`Student`对象，因此通过引用副本对对象属性所做的修改会反映到原始对象上。

总结

- 在Java中，无论是基本数据类型还是引用数据类型，参数传递都是通过值传递进行的。
- 对于基本数据类型，传递的是值的副本。
- 对于引用数据类型，传递的是引用（即内存地址）的副本，但操作的是同一个对象。



## 为什么不建议使用异常来控制业务流程？

1. 性能开销：
   异常处理机制通常涉及更多的性能开销。当异常被抛出时，JVM需要构建异常对象，并可能涉及堆栈跟踪等额外操作。如果异常被频繁用于控制正常业务流程，这将导致不必要的性能损耗。
2. 代码可读性和维护性：
   使用异常来控制业务逻辑会使得代码难以理解和维护。异常应该仅用于异常情况，而不是用于控制正常的业务逻辑流程。过度使用异常会使得代码逻辑混乱，难以追踪和理解。
3. 滥用异常机制：
   异常机制是为了处理异常情况而设计的，而不是用于常规的控制流。滥用异常机制可能会导致程序逻辑不清晰，增加了程序的复杂性和出错的可能性。

## HashMap的数据结构是怎么样的

HashMap的数据结构在不同的JDK版本中有所演变，但核心思想保持一致。

HashMap底层主要基于**数组+链表+红黑树**的数据结构实现（在JDK 1.8及以后版本中）。这种设计是为了在保持较快的访问速度的同时，解决哈希冲突问题。

1. **数组**：HashMap内部维护一个Node类型的数组，用于存储元素。数组的每个位置称为一个“桶”（bucket）。

2. **链表**：当多个键值对的哈希值相同（即发生了哈希冲突）时，这些键值对会被存储在同一桶内的链表中。在JDK 1.8之前，链表使用头插法插入新元素；而在JDK 1.8及以后，链表使用尾插法插入新元素。

3. **红黑树**：当某个桶内的链表长度超过一定阈值（默认为8，且数组长度大于64）时，链表会被转换为红黑树，以提高搜索效率。红黑树是一种自平衡二叉查找树，可以在对数时间内完成查找、插入和删除操作。



## 常见的Hash冲突的解决方式

哈希冲突是指在使用哈希函数时，两个不同的输入得到了相同的输出值。

常见的哈希冲突解决方法

1. **开放定址法**

**原理**：当哈希冲突发生时，通过某种探测技术在散列表中形成一个探测序列，直到找到一个开放的地址（即该地址单元为空）为止。探测序列的生成方式有多种，如线性探测、平方探测和伪随机探测。

* **线性探测**：按顺序决定下一个探测地址，即每次冲突时，将探测地址向后移动一个位置。
* **平方探测**：探测地址的增量为平方数序列，如1^2, -1^2, 2^2, -2^2, ...。
* **伪随机探测**：通过伪随机数生成器产生一个随机序列作为探测地址的增量。

**应用场景**：适用于表长可以动态增长且装载因子（表中元素个数与表长的比值）不是特别大的情况。

2. **链地址法**

**原理**：将哈希表的每个槽位视为链表的头指针，所有哈希值相同的元素都放入同一个链表中。这样，即使哈希冲突，也只是在同一个链表内部进行处理。

**应用场景**：适用于哈希冲突较为频繁，且表长不易动态变化的情况。Java中的HashMap就采用了链地址法来解决哈希冲突。

3. **再哈希法**

**原理**：当哈希冲突发生时，使用第二个哈希函数计算增量，并将该增量加到原哈希值上，形成新的探测地址。如果新地址仍然冲突，则继续用第二个哈希函数计算增量，直到找到空位置为止。

**应用场景**：适用于需要减少聚集现象，且可以接受额外计算开销的情况。

4. **建立公共溢出区**

**原理**：将哈希表分为基本表和溢出表两部分。当哈希冲突发生时，将冲突的元素放入溢出表中。查找时，先在基本表中查找，若未找到，则再到溢出表中查找。

**应用场景**：适用于哈希表大小固定，且冲突元素不是特别多的情况。



| 方法名称       | 原理简述                             | 优点                                     | 缺点                                       | 应用场景                             |
| -------------- | ------------------------------------ | ---------------------------------------- | ------------------------------------------ | ------------------------------------ |
| 开放定址法     | 冲突时，通过探测序列寻找空位置       | 实现简单，空间利用率高                   | 可能产生聚集现象，影响查找效率             | 表长可动态增长，装载因子适中         |
| 链地址法       | 哈希值相同的元素放入同一链表         | 处理冲突简单，无堆积现象，删除操作易实现 | 指针占用空间，可能影响空间效率             | 哈希冲突频繁，表长不易变化           |
| 再哈希法       | 使用第二个哈希函数计算增量，解决冲突 | 减少聚集现象，提高查找效率               | 增加计算时间，实现复杂                     | 需要减少聚集现象，可接受额外计算开销 |
| 建立公共溢出区 | 冲突元素放入溢出表，分开存储         | 避免聚集现象，保持哈希表结构不变         | 溢出区可能产生新的冲突，增加查找时间复杂度 | 哈希表大小固定，冲突元素不多         |





## 为什么HashMap链表长度等于8才转为红黑树？

源码注释，泊松分布。





## HashMap红黑树节点为多少时，会转回链表？

6









