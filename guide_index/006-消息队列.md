# 消息队列

## ✅为什么你们项目中要用消息队列？

我们之所以会使用消息队列，是因为随着业务的发展，单体架构支撑业务不再那么得心应手了，跟随着架构的升级，我们不可避免的引入了许多中间件，mq也是在这个大背景下引入的。引入MQ的时候，我们对MQ做了一些调研工作，大致分析了MQ的具有一下几大优点：①异步②解耦③削峰；

也分析了接入MQ带来的一些问题，主要如下：①降低了系统可⽤性②提高了系统复杂度③还会引入如何保证各个系统的⼀致性、如何保证消息不丢失等其他问题。

但是最后经过众多小伙伴们的综合评估，我们觉得引入消息队列的所带来的好处大于它的成本，所以我们选择使用消息队列。

##  ✅为什么你们项目中消息队列要用RabbitMQ？

我们调研对比了市面上常用的几种消息队列，比如Kafka、RabbitMQ、RocketMQ。其中kafaka吞吐量高，10W级别，延迟在ms级别，经过参数优化配置，可以做到数据不丢失，用作大数据计算和日志采集比较合适；RocketMQ，吞吐量也不错，官方号称也是10w级别，并且功能比kafaka更完善，他还是java语言开发的，对于使用java技术栈的我们也方便拓展；至于RabbitMQ，它的吞吐量在1W级别，但是这个吞吐量在我司已经够用了，虽然它不是java语言开发的，但是对于我们来说，基本没有拓展MQ的场景，他的消息基本也不会丢，更重要的是公司内部有许多以前在xxxx工作过的同事，xxxx以前就是大量使用的RabbitMQ，对于大家来说，使用起来比较熟悉，上手快。综上所述，我们选择了RabbitMQ作为消息队列。

## ✅你们是如何保证RabbitMQ的高可用的？

我们查阅了相关资料，发现RabbitMQ有3种部署模式：

①单机模式

②普通集群模式

③镜像集群模式。

其中单机模式主要是用于开发人员学习、部署用的，这里就不展开了。

至于普通集群模式，其实并没有实现高可用，他将元数据和实际数据都存放在一个MQ实例上，其他MQ实例只存放元数据，也就是说，如果存放实际数据的实例挂了，这个集群其实就不可用了。

镜像集群模式就解决了这个问题，所有的实例都存放了元数据和实际数据，但是这个模式其实很重，会消耗更多的网络带宽，并且没法像分布式式那么横向拓展。

## ✅你们是如何保证消息不被重复消费（消息的幂等性）？

我觉得重复消费不可怕，是正常的。因为生产者往MQ放消息的时候，也有可能会放重复的消息，所以最主要的是消费者要做好自己消费消息时的幂等性，这个一般是根据业务来控制的。我们常见的做法是根据一个唯一主键来判断。

## ✅你们是如何保证消息不丢失的（如何保证消息的可靠性）？

一个MQ消息完整的生命周期是从【生产者】——>【MQ】——>【消费者】。所以有可能发生消息丢失的环节有3个。

①消息从生产者发出，还没有到达MQ就丢失了。针对这种情况，我们一般有两种解决方案。第一种，开启RabbitMQ的事务同步机制，但是开启事务后，吞吐量会大幅下降。所以生产中我们会使用第二种方案，开启 confirm 模式，它和事务同步机制最大的不同是，它是异步的。在生产者开启了confirm 模式后，你每次写的消息都会被分配一个唯一id，如果写入了RabbitMQ，RabbitMQ会回传给你一个ack，表示自己接收成功了，如果RabbitMQ没能处理这个消息，那么他会回调你一个nack的方法。

②消息在RabbitMQ还未发送的时候就丢失了。这个问题一般是不会发生的，因为生产上面MQ都是要开启持久化的。

③还有可能是消费者弄丢了消息。比如消息才从mq出来，消费者就重启了，消息就丢失了。这个时候得关掉RabbitMQ的自动ack，改为消费端手动ack，只有消费者真正消费了，才告诉MQ消费了。 

## ✅你们是如何保证消息的顺序性的？

我觉得消息消费存在顺序性问题，很大的原因是因为消息没有做到原子性。也就是说我们只要在生产者发送消息的时候，将消息都放在一个queue里，那么消费者消费自然就是有顺序的。 要保证消息队列（MQ）中消息的顺序性，可以考虑以下方法： 

1. 单一消费者：使用单一消费者来处理消息，确保消息按照发送顺序被处理。这意味着在消息队列中只有一个消费者消费消息，并且消息处理是顺序执行的。这种方式简单直接，但可能会限制系统的扩展性和并发性能。 

2.  消息分区：将消息按照某种规则进行分区，使相同分区的消息被发送到同一个消费者进行处理。例如，可以根据某个关键字段（如订单ID、用户ID等）对消息进行分区，确保同一分区的消息被顺序处理。这样可以保证在同一分区中消息的顺序性，但不同分区的消息可能会并发处理。 

3. 消息排序：在发送消息时，为每个消息添加一个序号或时间戳，消费者在处理消息时根据序号或时间戳进行排序。这样，即使消息在传输过程中乱序到达，消费者仍然可以按照序号或时间戳重新排序消息。消息排序可以在消息生产者或消息消费者中进行。 

4. FIFO 队列：使用支持 FIFO（First-In-First-Out）顺序的队列，如 RabbitMQ 的优先级队列或 Apache Kafka 的单分区主题。这些队列保证消息按照发送顺序排列，并且只有一个消费者可以消费队列中的消息。

   

   ## ✅你们有遇到过MQ消息积压的情况吗？你们是怎么处理的？

   

   我在xxxx的时候，遇到过这个问题，当时大概积压了20w的数据。原因是因为consumer消费者下线了，但是生产者却一直在生产消息，因为这个对业务没有什么影响，所以当时我们直接是使用rabbitmq后台管理功能，将这些消息都丢弃了。

   后来我们对这个事情做了复盘，也提出了如果这个积压的消息影响了业务，我们该怎么做？ 总的来说，我觉得应该分为消费者和生产者两个部分。

   1、增加消费者数量：消息堆积了，消费不过来了，那就把消费者的数量增加一下，让更多的实例来消费这些消息。

   2、提升消费者消费速度：消费者消费的慢可能是消息堆积的主要原因，想办法提升消费速度，比如引入线程池本地消息存储后即返回成功后续再慢慢消费等。

   3、降低生产者的生产速度： 如果生产者可控的话，可以让生产者生成消息的速度慢一点。 

   ## ✅你们常用的消息模型有哪些？为什么这么用？

   我们一般认为rabbitmq有5种消息模型

   1、helloword模型

   2、work模型 这两种模型，在生产中都用的很少。

    3、订阅模型之直接模式（Direct）消息和队列一 一对应，我们这个用得最多

   4、订阅模型之广播模式（Fanout）一个消息对应多个队列，也就是说一个消息可以被多个队列消费

   5、订阅模型之主题模式（Topic）通过正则匹配消息和队列

